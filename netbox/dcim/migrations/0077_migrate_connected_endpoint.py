# Generated by Django 2.2.5 on 2019-10-06 19:01
from itertools import chain

from django.db import migrations


def migration_trace(apps, endpoint, cable_history=None):
    """
    Return a list representing a complete cable path, with each individual segment represented as a three-tuple:
        [
            (termination A, cable, termination B),
            (termination C, cable, termination D),
            (termination E, cable, termination F)
        ]

    This is a stand-alone version of Interface.trace() that is safe to use in migrations.
    """

    def get_generic_foreign_key(model_type, object_id):
        if model_type is None or object_id is None:
            return None

        object_model = apps.get_model(model_type.app_label, model_type.model)
        return object_model.objects.filter(pk=object_id).first()

    circuittermination_model = apps.get_model('circuits', 'CircuitTermination')
    frontport_model = apps.get_model('dcim', 'FrontPort')
    rearport_model = apps.get_model('dcim', 'RearPort')

    if not endpoint.cable:
        return [(endpoint, None, None)]

    # Record cable history to detect loops
    if cable_history is None:
        cable_history = []
    elif endpoint.cable in cable_history:
        return None
    cable_history.append(endpoint.cable)

    termination_a = get_generic_foreign_key(endpoint.cable.termination_a_type, endpoint.cable.termination_a_id)
    termination_b = get_generic_foreign_key(endpoint.cable.termination_b_type, endpoint.cable.termination_b_id)
    far_end = termination_b if termination_a == endpoint else termination_a
    path = [(endpoint, endpoint.cable, far_end)]

    if isinstance(far_end, circuittermination_model):
        peer_side = 'Z' if far_end.term_side == 'A' else 'A'
        peer_port = circuittermination_model.objects.filter(
            circuit=far_end.circuit,
            term_side=peer_side
        ).first()
    elif isinstance(far_end, frontport_model):
        peer_port = far_end.rear_port
    elif isinstance(far_end, rearport_model):
        peer_port = frontport_model.objects.filter(
            rear_port=far_end,
            rear_port_position=1,
        ).first()
    else:
        peer_port = None

    if isinstance(far_end, rearport_model) and far_end.positions > 1:
        # When we end up here we have a rear port with multiple front ports, and we don't know which front port
        # to continue with. So this is the end of the line
        return path

    while peer_port:
        path += migration_trace(apps, peer_port, cable_history)

        if isinstance(far_end, frontport_model) and isinstance(peer_port, rearport_model) and peer_port.positions > 1:
            # Trace the rear port separately, then continue with the corresponding front port
            saved_rear_port_position = far_end.rear_port_position

            far_end = path[-1][2]
            peer_port = None
            if isinstance(far_end, rearport_model):
                # The trace ends with a rear port, find the corresponding front port
                peer_port = frontport_model.objects.filter(
                    rear_port=far_end,
                    rear_port_position=saved_rear_port_position,
                ).first()

        else:
            # Everything else has already been handled by simple recursion
            peer_port = None

    return path


def migration_get_endpoint_attributes(endpoint):
    """
    This is a stand-alone version of CableTermination.get_endpoint_attributes() that is safe to use in migrations.
    """

    if not endpoint:
        return {}

    # We can't use isinstance because migrations give us fake classes
    attributes = {
        'id': endpoint.pk,
        'type': endpoint.__class__.__name__,
    }

    if endpoint.__class__.__name__ == 'CircuitTermination':
        attributes['cid'] = endpoint.circuit.cid
        attributes['provider'] = endpoint.circuit.provider.name
        attributes['site'] = endpoint.site.name
        attributes['site_slug'] = endpoint.site.slug
    elif endpoint.__class__.__name__ in ('Interface', 'FrontPort', 'RearPort'):
        attributes['name'] = endpoint.name

        parent = endpoint.device or endpoint.virtual_machine
        if parent.name:
            attributes['device'] = parent.name
            attributes['device_id'] = parent.pk
        elif parent.virtual_chassis and parent.virtual_chassis.master.name:
            attributes['device'] = "{}:{}".format(parent.virtual_chassis.master, parent.vc_position)
            attributes['device_id'] = parent.virtual_chassis.master.pk
        elif hasattr(parent, 'device_type'):
            attributes['device'] = "{}".format(parent.device_type)
            attributes['device_id'] = parent.pk
        else:
            attributes['device'] = ""

        attributes['site'] = parent.site.name

    return attributes


def to_generic_connected_endpoint(apps, schema_editor):
    print("\nReconstructing all endpoints...", end='')

    interface_model = apps.get_model('dcim', 'Interface')
    circuittermination_model = apps.get_model('circuits', 'CircuitTermination')
    contenttype_model = apps.get_model('contenttypes', 'ContentType')
    db_alias = schema_editor.connection.alias

    interface_endpoints = interface_model.objects.using(db_alias).all()
    circuittermination_endpoints = circuittermination_model.objects.using(db_alias).all()
    for endpoint in chain(interface_endpoints, circuittermination_endpoints):
        path = migration_trace(apps, endpoint)

        # The trace returns left and right, we just want a single list
        # We also want to skip the first endpoint, which is the starting point itself
        endpoints = [
            item for sublist in (
                [left, right] for left, cable, right in path
            )
            for item in sublist if item
        ][1:]

        if endpoints:
            model_type = contenttype_model.objects.get_for_model(endpoints[-1])
            endpoint.connected_endpoint_type = model_type
            endpoint.connected_endpoint_id = endpoints[-1].pk
        else:
            endpoint.connected_endpoint_type = None
            endpoint.connected_endpoint_id = None

        endpoint._trace = [migration_get_endpoint_attributes(endpoint) for endpoint in endpoints]
        endpoint.save()

        print(".", end='', flush=True)


def from_generic_connected_endpoint(apps, schema_editor):
    db_alias = schema_editor.connection.alias

    interface_model = apps.get_model('dcim', 'Interface')
    contenttype_model = apps.get_model('contenttypes', 'ContentType')
    circuittermination_model = apps.get_model('circuits', 'CircuitTermination')

    print("\nReverting interface endpoints in interfaces...", end='')

    model_type = contenttype_model.objects.get_for_model(interface_model)
    for interface in interface_model.objects.using(db_alias).filter(connected_endpoint_type=model_type):
        try:
            interface._connected_interface = interface_model.objects.get(pk=interface.connected_endpoint_id)
            interface.save()
            print(".", end='', flush=True)
        except interface_model.DoesNotExist:
            # Dangling generic foreign key
            print("X", end='', flush=True)

    print("\nReverting circuit termination endpoints in interfaces...", end='')

    model_type = contenttype_model.objects.get_for_model(circuittermination_model)
    for interface in interface_model.objects.using(db_alias).filter(connected_endpoint_type=model_type):
        try:
            interface._connected_circuittermination = circuittermination_model.objects.get(pk=interface.connected_endpoint_id)
            interface.save()
            print(".", end='', flush=True)
        except circuittermination_model.DoesNotExist:
            # Dangling generic foreign key
            print("X", end='', flush=True)

    print("\nReverting circuit termination endpoints...", end='')

    model_type = contenttype_model.objects.get_for_model(interface_model)
    for interface in circuittermination_model.objects.using(db_alias).filter(connected_endpoint_type=model_type):
        try:
            interface.old_connected_interface = interface_model.objects.get(pk=interface.connected_endpoint_id)
            interface.save()
            print(".", end='', flush=True)
        except interface_model.DoesNotExist:
            # Dangling generic foreign key
            print("X", end='', flush=True)


class Migration(migrations.Migration):
    dependencies = [
        ('circuits', '0016_generic_connected_endpoint'),
        ('contenttypes', '0002_remove_content_type_name'),
        ('dcim', '0076_add_generic_connected_endpoint'),
    ]

    operations = [
        migrations.RunPython(to_generic_connected_endpoint,
                             from_generic_connected_endpoint),
    ]
